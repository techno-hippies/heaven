// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt,
} from "@graphprotocol/graph-ts";

export class LikeSent extends ethereum.Event {
  get params(): LikeSent__Params {
    return new LikeSent__Params(this);
  }
}

export class LikeSent__Params {
  _event: LikeSent;

  constructor(event: LikeSent) {
    this._event = event;
  }

  get from(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get to(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class LikesAuthorized extends ethereum.Event {
  get params(): LikesAuthorized__Params {
    return new LikesAuthorized__Params(this);
  }
}

export class LikesAuthorized__Params {
  _event: LikesAuthorized;

  constructor(event: LikesAuthorized) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get nonce(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get maxLikes(): i32 {
    return this._event.parameters[2].value.toI32();
  }

  get expiry(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class MatchCreated extends ethereum.Event {
  get params(): MatchCreated__Params {
    return new MatchCreated__Params(this);
  }
}

export class MatchCreated__Params {
  _event: MatchCreated;

  constructor(event: MatchCreated) {
    this._event = event;
  }

  get user1(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get user2(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class MatchPending extends ethereum.Event {
  get params(): MatchPending__Params {
    return new MatchPending__Params(this);
  }
}

export class MatchPending__Params {
  _event: MatchPending;

  constructor(event: MatchPending) {
    this._event = event;
  }

  get pairKey(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get user1(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get user2(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get handle(): Bytes {
    return this._event.parameters[3].value.toBytes();
  }
}

export class ProfileSet extends ethereum.Event {
  get params(): ProfileSet__Params {
    return new ProfileSet__Params(this);
  }
}

export class ProfileSet__Params {
  _event: ProfileSet;

  constructor(event: ProfileSet) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class PublicDecryptionVerified extends ethereum.Event {
  get params(): PublicDecryptionVerified__Params {
    return new PublicDecryptionVerified__Params(this);
  }
}

export class PublicDecryptionVerified__Params {
  _event: PublicDecryptionVerified;

  constructor(event: PublicDecryptionVerified) {
    this._event = event;
  }

  get handlesList(): Array<Bytes> {
    return this._event.parameters[0].value.toBytesArray();
  }

  get abiEncodedCleartexts(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }
}

export class SharedValuesComputed extends ethereum.Event {
  get params(): SharedValuesComputed__Params {
    return new SharedValuesComputed__Params(this);
  }
}

export class SharedValuesComputed__Params {
  _event: SharedValuesComputed;

  constructor(event: SharedValuesComputed) {
    this._event = event;
  }

  get user1(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get user2(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class VerifiedAttributesSet extends ethereum.Event {
  get params(): VerifiedAttributesSet__Params {
    return new VerifiedAttributesSet__Params(this);
  }
}

export class VerifiedAttributesSet__Params {
  _event: VerifiedAttributesSet;

  constructor(event: VerifiedAttributesSet) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get nullifier(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }
}

export class DatingV3__getSharedBasicsHandlesResult {
  value0: Bytes;
  value1: Bytes;

  constructor(value0: Bytes, value1: Bytes) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromFixedBytes(this.value0));
    map.set("value1", ethereum.Value.fromFixedBytes(this.value1));
    return map;
  }

  getAgeHandle(): Bytes {
    return this.value0;
  }

  getGenderHandle(): Bytes {
    return this.value1;
  }
}

export class DatingV3__likeAuthsResult {
  value0: Bytes;
  value1: i32;
  value2: BigInt;
  value3: boolean;

  constructor(value0: Bytes, value1: i32, value2: BigInt, value3: boolean) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromFixedBytes(this.value0));
    map.set(
      "value1",
      ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(this.value1)),
    );
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    map.set("value3", ethereum.Value.fromBoolean(this.value3));
    return map;
  }

  getCandidateSetRoot(): Bytes {
    return this.value0;
  }

  getMaxLikes(): i32 {
    return this.value1;
  }

  getExpiry(): BigInt {
    return this.value2;
  }

  getActive(): boolean {
    return this.value3;
  }
}

export class DatingV3 extends ethereum.SmartContract {
  static bind(address: Address): DatingV3 {
    return new DatingV3("DatingV3", address);
  }

  DOMAIN_SEPARATOR(): Bytes {
    let result = super.call(
      "DOMAIN_SEPARATOR",
      "DOMAIN_SEPARATOR():(bytes32)",
      [],
    );

    return result[0].toBytes();
  }

  try_DOMAIN_SEPARATOR(): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "DOMAIN_SEPARATOR",
      "DOMAIN_SEPARATOR():(bytes32)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  EIP712_DOMAIN_TYPEHASH(): Bytes {
    let result = super.call(
      "EIP712_DOMAIN_TYPEHASH",
      "EIP712_DOMAIN_TYPEHASH():(bytes32)",
      [],
    );

    return result[0].toBytes();
  }

  try_EIP712_DOMAIN_TYPEHASH(): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "EIP712_DOMAIN_TYPEHASH",
      "EIP712_DOMAIN_TYPEHASH():(bytes32)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  G_MAN(): i32 {
    let result = super.call("G_MAN", "G_MAN():(uint8)", []);

    return result[0].toI32();
  }

  try_G_MAN(): ethereum.CallResult<i32> {
    let result = super.tryCall("G_MAN", "G_MAN():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  G_NON_BINARY(): i32 {
    let result = super.call("G_NON_BINARY", "G_NON_BINARY():(uint8)", []);

    return result[0].toI32();
  }

  try_G_NON_BINARY(): ethereum.CallResult<i32> {
    let result = super.tryCall("G_NON_BINARY", "G_NON_BINARY():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  G_TRANS_MAN(): i32 {
    let result = super.call("G_TRANS_MAN", "G_TRANS_MAN():(uint8)", []);

    return result[0].toI32();
  }

  try_G_TRANS_MAN(): ethereum.CallResult<i32> {
    let result = super.tryCall("G_TRANS_MAN", "G_TRANS_MAN():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  G_TRANS_WOMAN(): i32 {
    let result = super.call("G_TRANS_WOMAN", "G_TRANS_WOMAN():(uint8)", []);

    return result[0].toI32();
  }

  try_G_TRANS_WOMAN(): ethereum.CallResult<i32> {
    let result = super.tryCall("G_TRANS_WOMAN", "G_TRANS_WOMAN():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  G_WOMAN(): i32 {
    let result = super.call("G_WOMAN", "G_WOMAN():(uint8)", []);

    return result[0].toI32();
  }

  try_G_WOMAN(): ethereum.CallResult<i32> {
    let result = super.tryCall("G_WOMAN", "G_WOMAN():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  LIKE_AUTH_TYPEHASH(): Bytes {
    let result = super.call(
      "LIKE_AUTH_TYPEHASH",
      "LIKE_AUTH_TYPEHASH():(bytes32)",
      [],
    );

    return result[0].toBytes();
  }

  try_LIKE_AUTH_TYPEHASH(): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "LIKE_AUTH_TYPEHASH",
      "LIKE_AUTH_TYPEHASH():(bytes32)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  MASK_EVERYONE(): i32 {
    let result = super.call("MASK_EVERYONE", "MASK_EVERYONE():(uint16)", []);

    return result[0].toI32();
  }

  try_MASK_EVERYONE(): ethereum.CallResult<i32> {
    let result = super.tryCall("MASK_EVERYONE", "MASK_EVERYONE():(uint16)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  UNKNOWN_U8(): i32 {
    let result = super.call("UNKNOWN_U8", "UNKNOWN_U8():(uint8)", []);

    return result[0].toI32();
  }

  try_UNKNOWN_U8(): ethereum.CallResult<i32> {
    let result = super.tryCall("UNKNOWN_U8", "UNKNOWN_U8():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  admin(): Address {
    let result = super.call("admin", "admin():(address)", []);

    return result[0].toAddress();
  }

  try_admin(): ethereum.CallResult<Address> {
    let result = super.tryCall("admin", "admin():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  confidentialProtocolId(): BigInt {
    let result = super.call(
      "confidentialProtocolId",
      "confidentialProtocolId():(uint256)",
      [],
    );

    return result[0].toBigInt();
  }

  try_confidentialProtocolId(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "confidentialProtocolId",
      "confidentialProtocolId():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  directory(): Address {
    let result = super.call("directory", "directory():(address)", []);

    return result[0].toAddress();
  }

  try_directory(): ethereum.CallResult<Address> {
    let result = super.tryCall("directory", "directory():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getPendingMatchHandle(a: Address, b: Address): Bytes {
    let result = super.call(
      "getPendingMatchHandle",
      "getPendingMatchHandle(address,address):(bytes32)",
      [ethereum.Value.fromAddress(a), ethereum.Value.fromAddress(b)],
    );

    return result[0].toBytes();
  }

  try_getPendingMatchHandle(
    a: Address,
    b: Address,
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "getPendingMatchHandle",
      "getPendingMatchHandle(address,address):(bytes32)",
      [ethereum.Value.fromAddress(a), ethereum.Value.fromAddress(b)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  getSharedBasicsHandles(
    sharer: Address,
  ): DatingV3__getSharedBasicsHandlesResult {
    let result = super.call(
      "getSharedBasicsHandles",
      "getSharedBasicsHandles(address):(bytes32,bytes32)",
      [ethereum.Value.fromAddress(sharer)],
    );

    return new DatingV3__getSharedBasicsHandlesResult(
      result[0].toBytes(),
      result[1].toBytes(),
    );
  }

  try_getSharedBasicsHandles(
    sharer: Address,
  ): ethereum.CallResult<DatingV3__getSharedBasicsHandlesResult> {
    let result = super.tryCall(
      "getSharedBasicsHandles",
      "getSharedBasicsHandles(address):(bytes32,bytes32)",
      [ethereum.Value.fromAddress(sharer)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new DatingV3__getSharedBasicsHandlesResult(
        value[0].toBytes(),
        value[1].toBytes(),
      ),
    );
  }

  hasLiked(param0: Address, param1: Address): boolean {
    let result = super.call("hasLiked", "hasLiked(address,address):(bool)", [
      ethereum.Value.fromAddress(param0),
      ethereum.Value.fromAddress(param1),
    ]);

    return result[0].toBoolean();
  }

  try_hasLiked(param0: Address, param1: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("hasLiked", "hasLiked(address,address):(bool)", [
      ethereum.Value.fromAddress(param0),
      ethereum.Value.fromAddress(param1),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isMatch(param0: Address, param1: Address): boolean {
    let result = super.call("isMatch", "isMatch(address,address):(bool)", [
      ethereum.Value.fromAddress(param0),
      ethereum.Value.fromAddress(param1),
    ]);

    return result[0].toBoolean();
  }

  try_isMatch(param0: Address, param1: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("isMatch", "isMatch(address,address):(bool)", [
      ethereum.Value.fromAddress(param0),
      ethereum.Value.fromAddress(param1),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isVerified(param0: Address): boolean {
    let result = super.call("isVerified", "isVerified(address):(bool)", [
      ethereum.Value.fromAddress(param0),
    ]);

    return result[0].toBoolean();
  }

  try_isVerified(param0: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("isVerified", "isVerified(address):(bool)", [
      ethereum.Value.fromAddress(param0),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  likeAuths(param0: Address, param1: BigInt): DatingV3__likeAuthsResult {
    let result = super.call(
      "likeAuths",
      "likeAuths(address,uint64):(bytes32,uint8,uint64,bool)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromUnsignedBigInt(param1),
      ],
    );

    return new DatingV3__likeAuthsResult(
      result[0].toBytes(),
      result[1].toI32(),
      result[2].toBigInt(),
      result[3].toBoolean(),
    );
  }

  try_likeAuths(
    param0: Address,
    param1: BigInt,
  ): ethereum.CallResult<DatingV3__likeAuthsResult> {
    let result = super.tryCall(
      "likeAuths",
      "likeAuths(address,uint64):(bytes32,uint8,uint64,bool)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromUnsignedBigInt(param1),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new DatingV3__likeAuthsResult(
        value[0].toBytes(),
        value[1].toI32(),
        value[2].toBigInt(),
        value[3].toBoolean(),
      ),
    );
  }

  likesUsed(param0: Address, param1: BigInt): i32 {
    let result = super.call("likesUsed", "likesUsed(address,uint64):(uint8)", [
      ethereum.Value.fromAddress(param0),
      ethereum.Value.fromUnsignedBigInt(param1),
    ]);

    return result[0].toI32();
  }

  try_likesUsed(param0: Address, param1: BigInt): ethereum.CallResult<i32> {
    let result = super.tryCall(
      "likesUsed",
      "likesUsed(address,uint64):(uint8)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromUnsignedBigInt(param1),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  nonceUsed(param0: Address, param1: BigInt): boolean {
    let result = super.call("nonceUsed", "nonceUsed(address,uint64):(bool)", [
      ethereum.Value.fromAddress(param0),
      ethereum.Value.fromUnsignedBigInt(param1),
    ]);

    return result[0].toBoolean();
  }

  try_nonceUsed(param0: Address, param1: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "nonceUsed",
      "nonceUsed(address,uint64):(bool)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromUnsignedBigInt(param1),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  nullifierUsed(param0: Bytes): boolean {
    let result = super.call("nullifierUsed", "nullifierUsed(bytes32):(bool)", [
      ethereum.Value.fromFixedBytes(param0),
    ]);

    return result[0].toBoolean();
  }

  try_nullifierUsed(param0: Bytes): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "nullifierUsed",
      "nullifierUsed(bytes32):(bool)",
      [ethereum.Value.fromFixedBytes(param0)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  oracle(): Address {
    let result = super.call("oracle", "oracle():(address)", []);

    return result[0].toAddress();
  }

  try_oracle(): ethereum.CallResult<Address> {
    let result = super.tryCall("oracle", "oracle():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  profileInitialized(param0: Address): boolean {
    let result = super.call(
      "profileInitialized",
      "profileInitialized(address):(bool)",
      [ethereum.Value.fromAddress(param0)],
    );

    return result[0].toBoolean();
  }

  try_profileInitialized(param0: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "profileInitialized",
      "profileInitialized(address):(bool)",
      [ethereum.Value.fromAddress(param0)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  relayer(): Address {
    let result = super.call("relayer", "relayer():(address)", []);

    return result[0].toAddress();
  }

  try_relayer(): ethereum.CallResult<Address> {
    let result = super.tryCall("relayer", "relayer():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get _admin(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _directory(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _oracle(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get _relayer(): Address {
    return this._call.inputValues[3].value.toAddress();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class AuthorizeLikesCall extends ethereum.Call {
  get inputs(): AuthorizeLikesCall__Inputs {
    return new AuthorizeLikesCall__Inputs(this);
  }

  get outputs(): AuthorizeLikesCall__Outputs {
    return new AuthorizeLikesCall__Outputs(this);
  }
}

export class AuthorizeLikesCall__Inputs {
  _call: AuthorizeLikesCall;

  constructor(call: AuthorizeLikesCall) {
    this._call = call;
  }

  get user(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get candidateSetRoot(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get maxLikes(): i32 {
    return this._call.inputValues[2].value.toI32();
  }

  get expiry(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get nonce(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }

  get signature(): Bytes {
    return this._call.inputValues[5].value.toBytes();
  }
}

export class AuthorizeLikesCall__Outputs {
  _call: AuthorizeLikesCall;

  constructor(call: AuthorizeLikesCall) {
    this._call = call;
  }
}

export class FinalizeMatchCall extends ethereum.Call {
  get inputs(): FinalizeMatchCall__Inputs {
    return new FinalizeMatchCall__Inputs(this);
  }

  get outputs(): FinalizeMatchCall__Outputs {
    return new FinalizeMatchCall__Outputs(this);
  }
}

export class FinalizeMatchCall__Inputs {
  _call: FinalizeMatchCall;

  constructor(call: FinalizeMatchCall) {
    this._call = call;
  }

  get user1(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get user2(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get isMutualOk(): boolean {
    return this._call.inputValues[2].value.toBoolean();
  }

  get decryptionProof(): Bytes {
    return this._call.inputValues[3].value.toBytes();
  }
}

export class FinalizeMatchCall__Outputs {
  _call: FinalizeMatchCall;

  constructor(call: FinalizeMatchCall) {
    this._call = call;
  }
}

export class SetBasicsCall extends ethereum.Call {
  get inputs(): SetBasicsCall__Inputs {
    return new SetBasicsCall__Inputs(this);
  }

  get outputs(): SetBasicsCall__Outputs {
    return new SetBasicsCall__Outputs(this);
  }
}

export class SetBasicsCall__Inputs {
  _call: SetBasicsCall;

  constructor(call: SetBasicsCall) {
    this._call = call;
  }

  get claimedAge(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get genderId(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get desiredMask(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }

  get shareAge(): Bytes {
    return this._call.inputValues[3].value.toBytes();
  }

  get shareGender(): Bytes {
    return this._call.inputValues[4].value.toBytes();
  }

  get proof(): Bytes {
    return this._call.inputValues[5].value.toBytes();
  }
}

export class SetBasicsCall__Outputs {
  _call: SetBasicsCall;

  constructor(call: SetBasicsCall) {
    this._call = call;
  }
}

export class SetDirectoryCall extends ethereum.Call {
  get inputs(): SetDirectoryCall__Inputs {
    return new SetDirectoryCall__Inputs(this);
  }

  get outputs(): SetDirectoryCall__Outputs {
    return new SetDirectoryCall__Outputs(this);
  }
}

export class SetDirectoryCall__Inputs {
  _call: SetDirectoryCall;

  constructor(call: SetDirectoryCall) {
    this._call = call;
  }

  get _directory(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetDirectoryCall__Outputs {
  _call: SetDirectoryCall;

  constructor(call: SetDirectoryCall) {
    this._call = call;
  }
}

export class SetOracleCall extends ethereum.Call {
  get inputs(): SetOracleCall__Inputs {
    return new SetOracleCall__Inputs(this);
  }

  get outputs(): SetOracleCall__Outputs {
    return new SetOracleCall__Outputs(this);
  }
}

export class SetOracleCall__Inputs {
  _call: SetOracleCall;

  constructor(call: SetOracleCall) {
    this._call = call;
  }

  get _oracle(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetOracleCall__Outputs {
  _call: SetOracleCall;

  constructor(call: SetOracleCall) {
    this._call = call;
  }
}

export class SetRelayerCall extends ethereum.Call {
  get inputs(): SetRelayerCall__Inputs {
    return new SetRelayerCall__Inputs(this);
  }

  get outputs(): SetRelayerCall__Outputs {
    return new SetRelayerCall__Outputs(this);
  }
}

export class SetRelayerCall__Inputs {
  _call: SetRelayerCall;

  constructor(call: SetRelayerCall) {
    this._call = call;
  }

  get _relayer(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetRelayerCall__Outputs {
  _call: SetRelayerCall;

  constructor(call: SetRelayerCall) {
    this._call = call;
  }
}

export class SetVerifiedAttributesCall extends ethereum.Call {
  get inputs(): SetVerifiedAttributesCall__Inputs {
    return new SetVerifiedAttributesCall__Inputs(this);
  }

  get outputs(): SetVerifiedAttributesCall__Outputs {
    return new SetVerifiedAttributesCall__Outputs(this);
  }
}

export class SetVerifiedAttributesCall__Inputs {
  _call: SetVerifiedAttributesCall;

  constructor(call: SetVerifiedAttributesCall) {
    this._call = call;
  }

  get user(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get exactAge(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get biologicalSex(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }

  get nullifier(): Bytes {
    return this._call.inputValues[3].value.toBytes();
  }

  get proof(): Bytes {
    return this._call.inputValues[4].value.toBytes();
  }

  get userSig(): Bytes {
    return this._call.inputValues[5].value.toBytes();
  }
}

export class SetVerifiedAttributesCall__Outputs {
  _call: SetVerifiedAttributesCall;

  constructor(call: SetVerifiedAttributesCall) {
    this._call = call;
  }
}

export class SubmitLikeCall extends ethereum.Call {
  get inputs(): SubmitLikeCall__Inputs {
    return new SubmitLikeCall__Inputs(this);
  }

  get outputs(): SubmitLikeCall__Outputs {
    return new SubmitLikeCall__Outputs(this);
  }
}

export class SubmitLikeCall__Inputs {
  _call: SubmitLikeCall;

  constructor(call: SubmitLikeCall) {
    this._call = call;
  }

  get liker(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get target(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get nonce(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get merkleProof(): Array<Bytes> {
    return this._call.inputValues[3].value.toBytesArray();
  }
}

export class SubmitLikeCall__Outputs {
  _call: SubmitLikeCall;

  constructor(call: SubmitLikeCall) {
    this._call = call;
  }
}

export class TransferAdminCall extends ethereum.Call {
  get inputs(): TransferAdminCall__Inputs {
    return new TransferAdminCall__Inputs(this);
  }

  get outputs(): TransferAdminCall__Outputs {
    return new TransferAdminCall__Outputs(this);
  }
}

export class TransferAdminCall__Inputs {
  _call: TransferAdminCall;

  constructor(call: TransferAdminCall) {
    this._call = call;
  }

  get _newAdmin(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class TransferAdminCall__Outputs {
  _call: TransferAdminCall;

  constructor(call: TransferAdminCall) {
    this._call = call;
  }
}
