// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal,
} from "@graphprotocol/graph-ts";

export class Profile extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Profile entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Profile must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Profile", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): Profile | null {
    return changetype<Profile | null>(
      store.get_in_block("Profile", id.toHexString()),
    );
  }

  static load(id: Bytes): Profile | null {
    return changetype<Profile | null>(store.get("Profile", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get animeCid(): Bytes | null {
    let value = this.get("animeCid");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set animeCid(value: Bytes | null) {
    if (!value) {
      this.unset("animeCid");
    } else {
      this.set("animeCid", Value.fromBytes(<Bytes>value));
    }
  }

  get encPhotoCid(): Bytes | null {
    let value = this.get("encPhotoCid");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set encPhotoCid(value: Bytes | null) {
    if (!value) {
      this.unset("encPhotoCid");
    } else {
      this.set("encPhotoCid", Value.fromBytes(<Bytes>value));
    }
  }

  get ageBucket(): i32 {
    let value = this.get("ageBucket");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set ageBucket(value: i32) {
    this.set("ageBucket", Value.fromI32(value));
  }

  get verifiedLevel(): i32 {
    let value = this.get("verifiedLevel");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set verifiedLevel(value: i32) {
    this.set("verifiedLevel", Value.fromI32(value));
  }

  get claimedAgeBucket(): i32 {
    let value = this.get("claimedAgeBucket");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set claimedAgeBucket(value: i32) {
    this.set("claimedAgeBucket", Value.fromI32(value));
  }

  get genderIdentity(): i32 {
    let value = this.get("genderIdentity");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set genderIdentity(value: i32) {
    this.set("genderIdentity", Value.fromI32(value));
  }

  get modelVersion(): i32 {
    let value = this.get("modelVersion");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set modelVersion(value: i32) {
    this.set("modelVersion", Value.fromI32(value));
  }

  get updatedAt(): BigInt {
    let value = this.get("updatedAt");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set updatedAt(value: BigInt) {
    this.set("updatedAt", Value.fromBigInt(value));
  }

  get profileInitialized(): boolean {
    let value = this.get("profileInitialized");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set profileInitialized(value: boolean) {
    this.set("profileInitialized", Value.fromBoolean(value));
  }

  get isVerified(): boolean {
    let value = this.get("isVerified");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set isVerified(value: boolean) {
    this.set("isVerified", Value.fromBoolean(value));
  }

  get likesSent(): LikeLoader {
    return new LikeLoader(
      "Profile",
      this.get("id")!.toBytes().toHexString(),
      "likesSent",
    );
  }

  get likesReceived(): LikeLoader {
    return new LikeLoader(
      "Profile",
      this.get("id")!.toBytes().toHexString(),
      "likesReceived",
    );
  }

  get matchesAsUser1(): MatchLoader {
    return new MatchLoader(
      "Profile",
      this.get("id")!.toBytes().toHexString(),
      "matchesAsUser1",
    );
  }

  get matchesAsUser2(): MatchLoader {
    return new MatchLoader(
      "Profile",
      this.get("id")!.toBytes().toHexString(),
      "matchesAsUser2",
    );
  }

  get totalLikesSent(): i32 {
    let value = this.get("totalLikesSent");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set totalLikesSent(value: i32) {
    this.set("totalLikesSent", Value.fromI32(value));
  }

  get totalLikesReceived(): i32 {
    let value = this.get("totalLikesReceived");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set totalLikesReceived(value: i32) {
    this.set("totalLikesReceived", Value.fromI32(value));
  }

  get totalMatches(): i32 {
    let value = this.get("totalMatches");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set totalMatches(value: i32) {
    this.set("totalMatches", Value.fromI32(value));
  }

  get createdAt(): BigInt {
    let value = this.get("createdAt");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set createdAt(value: BigInt) {
    this.set("createdAt", Value.fromBigInt(value));
  }

  get createdTxHash(): Bytes {
    let value = this.get("createdTxHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set createdTxHash(value: Bytes) {
    this.set("createdTxHash", Value.fromBytes(value));
  }
}

export class Like extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Like entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Like must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Like", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Like | null {
    return changetype<Like | null>(store.get_in_block("Like", id));
  }

  static load(id: string): Like | null {
    return changetype<Like | null>(store.get("Like", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class PendingMatch extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PendingMatch entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type PendingMatch must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("PendingMatch", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): PendingMatch | null {
    return changetype<PendingMatch | null>(
      store.get_in_block("PendingMatch", id.toHexString()),
    );
  }

  static load(id: Bytes): PendingMatch | null {
    return changetype<PendingMatch | null>(
      store.get("PendingMatch", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get user1(): Bytes {
    let value = this.get("user1");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set user1(value: Bytes) {
    this.set("user1", Value.fromBytes(value));
  }

  get user2(): Bytes {
    let value = this.get("user2");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set user2(value: Bytes) {
    this.set("user2", Value.fromBytes(value));
  }

  get mutualOkHandle(): Bytes {
    let value = this.get("mutualOkHandle");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set mutualOkHandle(value: Bytes) {
    this.set("mutualOkHandle", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get finalized(): boolean {
    let value = this.get("finalized");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set finalized(value: boolean) {
    this.set("finalized", Value.fromBoolean(value));
  }

  get finalizedAt(): BigInt | null {
    let value = this.get("finalizedAt");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set finalizedAt(value: BigInt | null) {
    if (!value) {
      this.unset("finalizedAt");
    } else {
      this.set("finalizedAt", Value.fromBigInt(<BigInt>value));
    }
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class Match extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Match entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Match must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Match", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Match | null {
    return changetype<Match | null>(store.get_in_block("Match", id));
  }

  static load(id: string): Match | null {
    return changetype<Match | null>(store.get("Match", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user1(): Bytes {
    let value = this.get("user1");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set user1(value: Bytes) {
    this.set("user1", Value.fromBytes(value));
  }

  get user2(): Bytes {
    let value = this.get("user2");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set user2(value: Bytes) {
    this.set("user2", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class LikeAuthorization extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LikeAuthorization entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type LikeAuthorization must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("LikeAuthorization", id.toString(), this);
    }
  }

  static loadInBlock(id: string): LikeAuthorization | null {
    return changetype<LikeAuthorization | null>(
      store.get_in_block("LikeAuthorization", id),
    );
  }

  static load(id: string): LikeAuthorization | null {
    return changetype<LikeAuthorization | null>(
      store.get("LikeAuthorization", id),
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get candidateSetRoot(): Bytes {
    let value = this.get("candidateSetRoot");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set candidateSetRoot(value: Bytes) {
    this.set("candidateSetRoot", Value.fromBytes(value));
  }

  get maxLikes(): i32 {
    let value = this.get("maxLikes");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set maxLikes(value: i32) {
    this.set("maxLikes", Value.fromI32(value));
  }

  get likesUsed(): i32 {
    let value = this.get("likesUsed");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set likesUsed(value: i32) {
    this.set("likesUsed", Value.fromI32(value));
  }

  get expiry(): BigInt {
    let value = this.get("expiry");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set expiry(value: BigInt) {
    this.set("expiry", Value.fromBigInt(value));
  }

  get nonce(): BigInt {
    let value = this.get("nonce");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set nonce(value: BigInt) {
    this.set("nonce", Value.fromBigInt(value));
  }

  get active(): boolean {
    let value = this.get("active");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set active(value: boolean) {
    this.set("active", Value.fromBoolean(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class GlobalStats extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save GlobalStats entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type GlobalStats must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("GlobalStats", id.toString(), this);
    }
  }

  static loadInBlock(id: string): GlobalStats | null {
    return changetype<GlobalStats | null>(
      store.get_in_block("GlobalStats", id),
    );
  }

  static load(id: string): GlobalStats | null {
    return changetype<GlobalStats | null>(store.get("GlobalStats", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get totalProfiles(): i32 {
    let value = this.get("totalProfiles");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set totalProfiles(value: i32) {
    this.set("totalProfiles", Value.fromI32(value));
  }

  get totalLikes(): i32 {
    let value = this.get("totalLikes");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set totalLikes(value: i32) {
    this.set("totalLikes", Value.fromI32(value));
  }

  get totalMatches(): i32 {
    let value = this.get("totalMatches");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set totalMatches(value: i32) {
    this.set("totalMatches", Value.fromI32(value));
  }

  get totalPendingMatches(): i32 {
    let value = this.get("totalPendingMatches");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set totalPendingMatches(value: i32) {
    this.set("totalPendingMatches", Value.fromI32(value));
  }

  get lastActivityAt(): BigInt | null {
    let value = this.get("lastActivityAt");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set lastActivityAt(value: BigInt | null) {
    if (!value) {
      this.unset("lastActivityAt");
    } else {
      this.set("lastActivityAt", Value.fromBigInt(<BigInt>value));
    }
  }
}

export class LikeLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): Like[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<Like[]>(value);
  }
}

export class MatchLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): Match[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<Match[]>(value);
  }
}
